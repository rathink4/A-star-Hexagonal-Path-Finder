/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/data_structures.ts":
/*!********************************!*\
  !*** ./src/data_structures.ts ***!
  \********************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _PriorityQueue_list;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PriorityQueue = void 0;\nclass PriorityQueue {\n    constructor() {\n        _PriorityQueue_list.set(this, []);\n    }\n    get size() {\n        return __classPrivateFieldGet(this, _PriorityQueue_list, \"f\").length;\n    }\n    // get isFull() {\n    //     return this.#capacity !== null && this.size === this.#capacity\n    // }\n    get isEmpty() {\n        return this.size === 0;\n    }\n    enqueue(item, priority = 0) {\n        priority = Math.max(priority, 0);\n        const element = { item, priority };\n        if (this.isEmpty || element.priority <= __classPrivateFieldGet(this, _PriorityQueue_list, \"f\")[this.size - 1].priority) {\n            __classPrivateFieldGet(this, _PriorityQueue_list, \"f\").push(element);\n        }\n        else {\n            for (let i = 0; i < this.size; i++) {\n                if (element.priority > __classPrivateFieldGet(this, _PriorityQueue_list, \"f\")[i].priority) {\n                    __classPrivateFieldGet(this, _PriorityQueue_list, \"f\").splice(i, 0, element);\n                    break;\n                }\n            }\n        }\n        return this.size;\n    }\n    dequeue() {\n        return __classPrivateFieldGet(this, _PriorityQueue_list, \"f\").shift().item;\n    }\n    hasItem(searchCell) {\n        return __classPrivateFieldGet(this, _PriorityQueue_list, \"f\").some(element => element.item.hex.q === searchCell.hex.q &&\n            element.item.hex.r === searchCell.hex.r);\n    }\n    getCell(searchCell) {\n        var _a;\n        const found = (_a = __classPrivateFieldGet(this, _PriorityQueue_list, \"f\").find(element => element.item.hex.q === searchCell.hex.q &&\n            element.item.hex.r === searchCell.hex.r)) === null || _a === void 0 ? void 0 : _a.item;\n        if (!found) {\n            throw new Error(\"Cell not found\");\n        }\n        return found;\n    }\n    remove(cell) {\n        const index = __classPrivateFieldGet(this, _PriorityQueue_list, \"f\").findIndex(element => element.item.hex.q === cell.hex.q &&\n            element.item.hex.r === cell.hex.r);\n        if (index !== -1) {\n            __classPrivateFieldGet(this, _PriorityQueue_list, \"f\").splice(index, 1);\n        }\n    }\n}\nexports.PriorityQueue = PriorityQueue;\n_PriorityQueue_list = new WeakMap();\n\n\n//# sourceURL=webpack://hexa-path-finder/./src/data_structures.ts?");

/***/ }),

/***/ "./src/hex_utils.ts":
/*!**************************!*\
  !*** ./src/hex_utils.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getHexVertex = getHexVertex;\nexports.hexToPixel = hexToPixel;\nexports.mapPixelToHex = mapPixelToHex;\nexports.isHexInGrid = isHexInGrid;\nexports.findNeighborHexes = findNeighborHexes;\nfunction getHexVertex(center, size, i) {\n    let angle_deg = 60 * i - 30;\n    let angle_rad = Math.PI / 180 * angle_deg;\n    let pos_x = center.x + size * Math.cos(angle_rad);\n    let pos_y = center.y + size * Math.sin(angle_rad);\n    return { x: pos_x, y: pos_y };\n}\nfunction hexToPixel(h, size, origin) {\n    let px = size * Math.sqrt(3) * (h.q + h.r / 2) + origin.x;\n    let py = size * 3 / 2 * h.r + origin.y;\n    return { x: px, y: py };\n}\nfunction roundToAxialCoordinates(h_r, h_q, h_s) {\n    let q = Math.round(h_q);\n    let r = Math.round(h_r);\n    let s = Math.round(h_s);\n    let q_diff = Math.abs(q - h_q);\n    let r_diff = Math.abs(r - h_r);\n    let s_diff = Math.abs(s - h_s);\n    if (q_diff > r_diff && q_diff > s_diff) {\n        q = -r - s;\n    }\n    else if (r_diff > s_diff) {\n        r = -q - s;\n    }\n    else {\n        s = -q - r;\n    }\n    return { r: r, q: q };\n}\nfunction mapPixelToHex(point, size, origin) {\n    let px = point.x - origin.x;\n    let py = point.y - origin.y;\n    let q = (Math.sqrt(3) / 3 * px - 1 / 3 * py) / size;\n    let r = (2 / 3 * py) / size;\n    let hex_coord = roundToAxialCoordinates(r, q, -q - r);\n    return hex_coord;\n}\nfunction isHexInGrid(hex, gridRadius) {\n    return Math.abs(hex.q) <= gridRadius &&\n        Math.abs(hex.r) <= gridRadius &&\n        Math.abs(hex.q + hex.r) <= gridRadius;\n}\nfunction findNeighborHexes(hex) {\n    const directions = [\n        { r: 0, q: 1 }, { r: -1, q: 1 }, { r: -1, q: 0 },\n        { r: 0, q: -1 }, { r: 1, q: -1 }, { r: 1, q: 0 }\n    ];\n    let neighbors = [];\n    directions.forEach(hexDir => {\n        let nr = hex.r + hexDir.r;\n        let nq = hex.q + hexDir.q;\n        let n = { r: nr, q: nq };\n        neighbors.push(n);\n    });\n    return neighbors;\n}\n\n\n//# sourceURL=webpack://hexa-path-finder/./src/hex_utils.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst data_structures_1 = __webpack_require__(/*! ./data_structures */ \"./src/data_structures.ts\");\nconst hex_utils_1 = __webpack_require__(/*! ./hex_utils */ \"./src/hex_utils.ts\");\nconst HEXSIZE = 30;\nconst HEXORIGIN = { x: 725, y: 350 };\nconst GRID_RADIUS = 6;\nconst generateMazeBtn = document.getElementById(\"maze_generator\");\nconst findPathBtn = document.getElementById(\"path_finder\");\nlet pathPosition;\nlet mazeModel;\nfunction drawSingleHex(hexCell) {\n    const canvas = document.getElementById(\"honeyCombMazeCanvas\");\n    const ctx = canvas.getContext(\"2d\");\n    const center = hexCell.pos;\n    ctx.beginPath();\n    const startVtx = (0, hex_utils_1.getHexVertex)(center, HEXSIZE, 0);\n    ctx.moveTo(startVtx.x, startVtx.y);\n    for (let i = 1; i <= 6; i++) {\n        const vertex = (0, hex_utils_1.getHexVertex)(center, HEXSIZE, i % 6);\n        ctx.lineTo(vertex.x, vertex.y);\n    }\n    ctx.fillStyle = '#ADD8E6';\n    ctx.fill();\n    for (let i = 0; i < 6; i++) {\n        if (hexCell.walls[i] === \"Open\")\n            continue;\n        let start = (0, hex_utils_1.getHexVertex)(center, HEXSIZE, i);\n        let end = (0, hex_utils_1.getHexVertex)(center, HEXSIZE, i + 1);\n        drawWall(start, end);\n    }\n}\nfunction drawWall(startVert, endVert) {\n    const canvas = document.getElementById(\"honeyCombMazeCanvas\");\n    const ctx = canvas.getContext(\"2d\");\n    ctx.beginPath();\n    ctx.moveTo(startVert.x, startVert.y);\n    ctx.lineTo(endVert.x, endVert.y);\n    ctx.stroke();\n    ctx.closePath();\n}\nfunction createModel() {\n    return {\n        grid: [],\n        currentHex: { r: 0, q: 0 },\n        stack: []\n    };\n}\nfunction createCell(_hex, _position) {\n    return {\n        walls: [\"Wall\", \"Wall\", \"Wall\", \"Wall\", \"Wall\", \"Wall\"],\n        hex: _hex,\n        pos: _position,\n        g: -1,\n        h: -1,\n        f: -1,\n        parent: null\n    };\n}\nfunction drawHoneyCombGrid(radius, mazeModel) {\n    const size = 2 * radius + 1;\n    mazeModel.grid = Array(size).fill(null).map(() => Array(size).fill(null));\n    for (let q = -radius; q <= radius; q++) {\n        const r1 = Math.max(-radius, -q - radius);\n        const r2 = Math.min(radius, -q + radius);\n        for (let r = r1; r <= r2; r++) {\n            const hex = { r, q };\n            const center = (0, hex_utils_1.hexToPixel)(hex, HEXSIZE, HEXORIGIN);\n            const cell = createCell(hex, center);\n            const arrayQ = q + radius;\n            const arrayR = r + radius;\n            mazeModel.grid[arrayR][arrayQ] = cell;\n            drawSingleHex(cell);\n        }\n    }\n    return mazeModel;\n}\nfunction getCursorPoition(canvas, event) {\n    const rect = canvas.getBoundingClientRect();\n    const x = event.clientX - rect.left;\n    const y = event.clientY - rect.top;\n    return { x: x, y: y };\n}\nfunction getCommonWall(hex1, hex2) {\n    const directions = [\n        { dr: 0, dq: 1, wall1: 1, wall2: 4 },\n        { dr: 0, dq: -1, wall1: 4, wall2: 1 },\n        { dr: -1, dq: 1, wall1: 0, wall2: 3 },\n        { dr: -1, dq: 0, wall1: 5, wall2: 2 },\n        { dr: 1, dq: 0, wall1: 2, wall2: 5 },\n        { dr: 1, dq: -1, wall1: 3, wall2: 0 }\n    ];\n    const dq = hex2.q - hex1.q;\n    const dr = hex2.r - hex1.r;\n    const direction = directions.find(dir => dir.dq === dq && dir.dr === dr);\n    if (!direction)\n        throw new Error(\"Hexes are not neighbors\");\n    return { hex1Wall: direction.wall1, hex2Wall: direction.wall2 };\n}\nfunction removeWall(currHex, neighHex) {\n    const { hex1Wall, hex2Wall } = getCommonWall(currHex, neighHex);\n    // Convert to array indices\n    const i1 = currHex.r + GRID_RADIUS;\n    const j1 = currHex.q + GRID_RADIUS;\n    const i2 = neighHex.r + GRID_RADIUS;\n    const j2 = neighHex.q + GRID_RADIUS;\n    // Remove walls in data structure\n    if (mazeModel.grid[i1] && mazeModel.grid[i1][j1]) {\n        const currHexCell = mazeModel.grid[i1][j1];\n        currHexCell.walls[hex1Wall] = \"Open\";\n        mazeModel.grid[i1][j1] = currHexCell;\n    }\n    if (mazeModel.grid[i2] && mazeModel.grid[i2][j2]) {\n        const neighHexCell = mazeModel.grid[i2][j2];\n        neighHexCell.walls[hex2Wall] = \"Open\";\n        mazeModel.grid[i2][j2] = neighHexCell;\n    }\n    const h1Center = (0, hex_utils_1.hexToPixel)(currHex, HEXSIZE, HEXORIGIN);\n    const i = hex1Wall - 1;\n    const h1Start = (0, hex_utils_1.getHexVertex)(h1Center, HEXSIZE, i);\n    const h1End = (0, hex_utils_1.getHexVertex)(h1Center, HEXSIZE, (i + 1) % 6);\n    const canvas = document.getElementById(\"honeyCombMazeCanvas\");\n    const ctx = canvas.getContext(\"2d\");\n    ctx.beginPath();\n    ctx.strokeStyle = '#ADD8E6'; // or whatever your background color is\n    ctx.lineWidth = 2;\n    ctx.moveTo(h1Start.x, h1Start.y);\n    ctx.lineTo(h1End.x, h1End.y);\n    ctx.stroke();\n    ctx.closePath();\n}\nfunction hexToKey(hex) {\n    return `${hex.r},${hex.q}`;\n}\nfunction paintSelectedCell(hex, color, counter = -1) {\n    const canvas = document.getElementById(\"honeyCombMazeCanvas\");\n    const ctx = canvas.getContext(\"2d\");\n    const center = (0, hex_utils_1.hexToPixel)(hex, HEXSIZE, HEXORIGIN);\n    ctx.beginPath();\n    const startVtx = (0, hex_utils_1.getHexVertex)(center, HEXSIZE - 5, 0);\n    ctx.moveTo(startVtx.x, startVtx.y);\n    for (let i = 1; i <= 6; i++) {\n        const vertex = (0, hex_utils_1.getHexVertex)(center, HEXSIZE - 5, i % 6);\n        ctx.lineTo(vertex.x, vertex.y);\n    }\n    // ctx.fillStyle = \"#04AA6D\"\n    ctx.fillStyle = color;\n    ctx.fill();\n    // Add counter number\n    if (counter !== -1) {\n        ctx.fillStyle = \"white\"; // text color\n        ctx.font = \"12px Arial\"; // font size and family\n        ctx.textAlign = \"center\";\n        ctx.textBaseline = \"middle\";\n        // Calculate position for the counter (top-right of hex)\n        const topRightVertex = (0, hex_utils_1.getHexVertex)(center, HEXSIZE - 15, 1); // Using vertex 1 (top-right)\n        // Draw counter\n        ctx.fillText(counter.toString(), topRightVertex.x, topRightVertex.y);\n    }\n}\nfunction hexToCell(hex) {\n    if (!(0, hex_utils_1.isHexInGrid)(hex, GRID_RADIUS)) {\n        throw new Error(`Hex coordinates (${hex.q},${hex.r}) are out of grid bounds`);\n    }\n    const i = hex.r + GRID_RADIUS;\n    const j = hex.q + GRID_RADIUS;\n    if (!mazeModel.grid[i] || !mazeModel.grid[i][j]) {\n        throw new Error(`No cell found at grid coordinates (${i},${j})`);\n    }\n    return mazeModel.grid[i][j];\n}\nfunction heuristic(start, goal) {\n    const x1 = start.pos.x;\n    const y1 = start.pos.y;\n    const x2 = goal.pos.x;\n    const y2 = goal.pos.y;\n    const distance = Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));\n    return distance;\n}\nfunction isValidNeighbour(current, neighbor) {\n    const { hex1Wall, hex2Wall } = getCommonWall(current, neighbor);\n    // Convert to array indices\n    let currentCell = hexToCell(current);\n    let neighCell = hexToCell(neighbor);\n    return (currentCell.walls[hex1Wall] === \"Open\" && neighCell.walls[hex2Wall] == \"Open\");\n}\nconst reconstructPath = (current) => __awaiter(void 0, void 0, void 0, function* () {\n    const path = [];\n    while (current !== null) {\n        //await new Promise(resolve => setTimeout(resolve, 50));\n        path.push(current);\n        if (current.parent === null)\n            break;\n        current = current.parent;\n    }\n    let count = 0;\n    let pathLength = path.length;\n    while (path.length > 0) {\n        const cell = path.pop();\n        count += 1;\n        if (count == 1)\n            continue;\n        if (cell) {\n            yield new Promise(resolve => setTimeout(resolve, 200));\n            count == pathLength ? paintSelectedCell(cell.hex, \"#04AA6D\", count) : paintSelectedCell(cell.hex, \"#9ACD32\", count);\n        }\n    }\n});\ngenerateMazeBtn.onclick = () => __awaiter(void 0, void 0, void 0, function* () {\n    generateMazeBtn.disabled = true;\n    generateMazeBtn.classList.add('disabled');\n    let maze_stack = mazeModel.stack;\n    let visited = new Set();\n    let currHex = mazeModel.currentHex;\n    visited.add(`${currHex.r},${currHex.q}`);\n    maze_stack.push(mazeModel.currentHex);\n    while (maze_stack.length !== 0) {\n        yield new Promise(resolve => setTimeout(resolve, 30));\n        let neighbourHexes = (0, hex_utils_1.findNeighborHexes)(currHex);\n        let unvisitedNeighbors = neighbourHexes.filter(hex => (0, hex_utils_1.isHexInGrid)(hex, GRID_RADIUS) && !visited.has(hexToKey(hex)));\n        if (unvisitedNeighbors.length > 0) {\n            maze_stack.push(currHex);\n            let randomIdx = Math.floor(Math.random() * unvisitedNeighbors.length);\n            let neighHex = unvisitedNeighbors[randomIdx];\n            //paintCurrCell(currHex)\n            //paintSelectedCell(neighHex)\n            removeWall(currHex, neighHex);\n            visited.add(`${neighHex.r},${neighHex.q}`);\n            maze_stack.push(neighHex);\n            currHex = neighHex;\n            continue;\n        }\n        else {\n            currHex = maze_stack.pop();\n            continue;\n        }\n    }\n    alert(\"Maze Generation: Complete!\");\n});\nfindPathBtn.onclick = () => {\n    var _a;\n    if (hexToKey(pathPosition[0]) === hexToKey(pathPosition[1])) {\n        alert(\"Path Found: We are already at the destination!\");\n        location.reload();\n    }\n    else if (pathPosition.length <= 1) {\n        alert(\"Unable to create path without starting and ending positions!\");\n    }\n    else {\n        const size = 2 * GRID_RADIUS + 1;\n        let openList = new data_structures_1.PriorityQueue();\n        let closedList = new Set();\n        let startHex = pathPosition[0];\n        let goalHex = pathPosition[1];\n        let start = hexToCell(startHex);\n        let goal = hexToCell(goalHex);\n        start.g = 0;\n        start.h = heuristic(start, goal);\n        start.f = start.g + start.h;\n        openList.enqueue(start, start.f);\n        while (!openList.isEmpty) {\n            let current = openList.dequeue();\n            if (hexToKey(current.hex) == hexToKey(goal.hex)) {\n                // recontruct the path from current\n                alert(\"Path Found: Recontructing Path\");\n                reconstructPath(current);\n            }\n            closedList.add(hexToKey(current.hex));\n            let neighbourHexes = (0, hex_utils_1.findNeighborHexes)(current.hex);\n            let unvisitedNeighbors = neighbourHexes.filter(hex => (0, hex_utils_1.isHexInGrid)(hex, GRID_RADIUS) && !closedList.has(hexToKey(hex)) && isValidNeighbour(current.hex, hex));\n            for (let i = 0; i < unvisitedNeighbors.length; i++) {\n                let neighbor = hexToCell(unvisitedNeighbors[i]);\n                let tempG = current.g + heuristic(current, neighbor);\n                if (!openList.hasItem(neighbor)) {\n                    neighbor.g = tempG;\n                    neighbor.h = heuristic(neighbor, goal);\n                    neighbor.f = neighbor.g + neighbor.h;\n                    neighbor.parent = current;\n                    openList.enqueue(neighbor, neighbor.f);\n                }\n                else if (tempG < ((_a = openList.getCell(neighbor)) === null || _a === void 0 ? void 0 : _a.g)) {\n                    let _neighbor = openList.getCell(neighbor);\n                    _neighbor.g = tempG;\n                    _neighbor.f = tempG + _neighbor.h;\n                    _neighbor.parent = current;\n                    openList.remove(neighbor);\n                    openList.enqueue(_neighbor, _neighbor.f);\n                }\n            }\n        }\n    }\n};\n// function printGrid(model: Model) {\n//     console.log(\"Grid Structure:\");\n//     model.grid.forEach((row, rowIndex) => {\n//         let rowStr = `Row ${rowIndex}: `;\n//         row.forEach((cell, colIndex) => {\n//             if (cell === null) {\n//                 rowStr += \"null \";\n//             } else {\n//                 rowStr += `(${cell.walls}) `;\n//             }\n//         });\n//         console.log(rowStr);\n//     });\n// }\nfunction main() {\n    const canvas = document.getElementById(\"honeyCombMazeCanvas\");\n    const ctx = canvas.getContext(\"2d\");\n    mazeModel = createModel();\n    drawHoneyCombGrid(GRID_RADIUS, mazeModel);\n    pathPosition = [];\n    canvas.addEventListener('mousedown', function (e) {\n        if (pathPosition.length < 2) {\n            let cursor_pixel = getCursorPoition(canvas, e);\n            let cursor_hex = (0, hex_utils_1.mapPixelToHex)(cursor_pixel, HEXSIZE, HEXORIGIN);\n            console.log(cursor_hex);\n            pathPosition.push(cursor_hex);\n            pathPosition.length == 1 ? paintSelectedCell(cursor_hex, \"#008CBA\", 1) : paintSelectedCell(cursor_hex, \"#04AA6D\");\n        }\n        else {\n            alert(\"Two positions seleteced: Try finding the path!\");\n        }\n    });\n}\nmain();\n\n\n//# sourceURL=webpack://hexa-path-finder/./src/index.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ })()
;